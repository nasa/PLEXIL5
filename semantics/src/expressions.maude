*** Function TODO: Review
**** We use shallow embedding for functions in constrast
**** to the deep embedding of values
fmod FUNCTION is
 protecting ARGUMENTS .
 sort Function .
endfm

*** Expressions
fmod EXPRESSION is
 protecting QUALIFIED .
 protecting VALUE .
 protecting FUNCTION .
 sorts Expression AssignmentTarget .
 subsort AssignmentTarget < Expression .
 op const              : Value                  -> Expression [format (b o)] .
 op var                : NeQualified            -> AssignmentTarget [format (b o)] .
 op arrayVar           : NeQualified            -> AssignmentTarget [format (b o)] .
 op arrayVar           : NeQualified Expression -> AssignmentTarget [format (b o)] .
 op lookup             : NeQualified Arguments  -> Expression [format (b o)] .
 op func               : Function Expression    -> Expression [format (b o)] . *** TODO: Review
 op lookupOnChange     : NeQualified Arguments Value   -> Expression [format (b o)] .
 op hasLookupOnChange? : Expression          -> Bool .
 op name               : NeQualified         -> Expression [format (b o)] .
 op default            :                     -> Expression [format (b o)] .
 op parameter          :                     -> Expression [format (b o)] .

 vars Q Q' : NeQualified .
 var V : Value .
 var F : Function .
 var E : Expression .
 vars Args : Arguments .

 op qualifyVarNames : Expression NeQualified -> Expression .
 eq qualifyVarNames(const(V),Q) = const(V) .
 eq qualifyVarNames(var(Q'),Q) = var((Q' . Q)) .
 eq qualifyVarNames(lookup(Q',Args),Q) = lookup(Q',Args) .
 eq qualifyVarNames(func(F,E),Q) = func(F,qualifyVarNames(E,Q)) .
 eq qualifyVarNames(lookupOnChange(Q',Args,V),Q) = lookupOnChange(Q',Args,V) .
endfm

view Expression from TRIV to EXPRESSION is
 sort Elt to Expression .
endv

*** Parameters
fmod PARAMETER is
 protecting LIST{Expression} * ( sort List{Expression} to Parameters,
                                 op nil to nilpar ) .
endfm
