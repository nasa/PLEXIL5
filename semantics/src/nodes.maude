fmod STATUS is
 sort Status .
 ops inactive waiting executing finishing iterationEnded failing finished : -> Status [format (r o)] .
 op statusdef : -> Status .
 eq statusdef = inactive .
endfm

fmod FAILURE is
 sort FailureType .
 ops exited parentExited parentFailed invariantFailed preconditionFailed postconditionFailed : -> FailureType .
endfm

fmod OUTCOME is
 protecting FAILURE .
 sort Outcome .

 ops skipped success none : -> Outcome .
 ops failure interrupted : FailureType -> Outcome .

 op outcomedef : -> Outcome .
 eq outcomedef = none .
endfm

mod NODE is
 inc CONFIGURATION * (op <_:_|_> to <_:_|_> [format (ni d d d d d d d)] ) .
 pr QUALIFIED .
 pr STATUS .
 pr OUTCOME .
 pr COMMAND .
 pr COMMANDINFO .
 pr EXPRESSION .
 pr RAT .
 pr MAYBE{CommandHandle} .

 subsort NeQualified < Oid .
 sort NodeType .
 subsort NodeType < Cid .
 ops list command retCommand assignment empty memory library command-on-execution : -> NodeType .
 sort DeclarationType .
 subsort DeclarationType < Cid .
 ops commandDeclaration stateDeclaration : -> DeclarationType .

 op status:_       : Status -> Attribute [ctor gather (&) format (u o o)] .
 op outcome:_      : Outcome -> Attribute [ctor gather (&)] .
 op command:_      : Command -> Attribute [ctor gather (&)] .
 op commandInfo:_  : CommandInfo -> Attribute [ctor gather (&)] .
 op qid:_          : Qualified -> Attribute [ctor gather (&)] .
 op extVar:_       : Qualified -> Attribute [ctor gather (&)] .
 op locVar:_       : Qualified -> Attribute [ctor gather (&)] .
 op _:=_           : Qualified Expression -> Attribute [ctor] .
 op _[_]:=_        : Qualified Expression Expression -> Attribute [ctor] .
 op active:_       : Bool -> Attribute [ctor gather (&)] .
 op initVal:_      : Value -> Attribute [ctor gather (&)] .
 op actVal:_       : Value -> Attribute [ctor gather (&)] .
 op prevVal:_      : Value -> Attribute [ctor gather (&)] .
 op node:_         : Expression -> Attribute [ctor gather (&)] .
 op threshold:_    : Value -> Attribute [ctor gather (&)] .
 op fromrepeat:_   : Bool -> Attribute [ctor gather (&)] .
 op arguments:_    : Arguments -> Attribute [ctor gather (&)] .
 op handle:_       : Maybe{CommandHandle} -> Attribute [ctor gather (&)] .
 op value:_       : Nat -> Attribute [ctor gather (&)] .
 op returnVariable:_ : Qualified -> Attribute [ctor gather (&)] .

*** Body conditions
 op repeatc:_       : Expression -> Attribute [ctor gather (&)] .
 op startc:_        : Expression -> Attribute [ctor gather (&)] .
 op endc:_          : Expression -> Attribute [ctor gather (&)] .
 op exitc:_         : Expression -> Attribute [ctor gather (&)] .
 op post:_          : Expression -> Attribute [ctor gather (&)] .
 op skip:_          : Expression -> Attribute [ctor gather (&)] .
 op pre:_           : Expression -> Attribute [ctor gather (&)] .
 op inv:_           : Expression -> Attribute [ctor gather (&)] .
 op suspended:_     : Bool -> Attribute [ctor gather (&)] .

  *** Interface attributes elements
  op name:_       : Identifier       -> Attribute .
  op return:_     : Identifier       -> Attribute .

 op getRepeatCondition : AttributeSet -> Expression .
 eq getRepeatCondition(repeatc: E:Expression , As:AttributeSet) = E:Expression .


 op defcond : NodeType -> AttributeSet .
 eq defcond(NTy)
  = endc: default, --- const(val(true)),
    exitc: default, --- const(val(false)),
    inv: default, --- const(val(true)),
    post: default, --- const(val(true)),
    pre: default, --- const(val(true)),
    repeatc: default, --- const(val(false)),
    skip: default, --- const(val(false)),
    startc: default --- const(val(true))
 .


var NTy : NodeType .
 var repeatC : Expression .

 op defaultAttributes : NodeType Expression -> AttributeSet .
 eq defaultAttributes(NTy, repeatC)
  = defcond(NTy),
    status: statusdef,
    outcome: outcomedef,
    active: true,
    suspended: false
 .

 vars AtS AtS' : AttributeSet .
 vars E E' : Expression .
 vars R R' : Rat .


*** Attribute manipulation ***

op getAttribute : Attribute -> Expression .
eq getAttribute(repeatc: E) = E .
eq getAttribute(startc:  E) = E .
eq getAttribute(endc:    E) = E .
eq getAttribute(exitc:   E) = E .
eq getAttribute(post:    E) = E .
eq getAttribute(skip:    E) = E .
eq getAttribute(pre:     E) = E .
eq getAttribute(inv:     E) = E .

op replaceAttribute : Attribute Expression -> Attribute .
eq replaceAttribute(repeatc: E, E') = repeatc: E' .
eq replaceAttribute(startc:  E, E') = startc:  E' .
eq replaceAttribute(endc:    E, E') = endc:    E' .
eq replaceAttribute(exitc:   E, E') = exitc:   E' .
eq replaceAttribute(post:    E, E') = post:    E' .
eq replaceAttribute(skip:    E, E') = skip:    E' .
eq replaceAttribute(pre:     E, E') = pre:     E' .
eq replaceAttribute(inv:     E, E') = inv:     E' .


 op _/_ : AttributeSet AttributeSet -> [AttributeSet] [prec 80] .
 eq (repeatc: E,  AtS) / (repeatc: E',  AtS') = (repeatc: E',  AtS) / AtS' .
 eq (startc: E,   AtS) / (startc: E',   AtS') = (startc: E',   AtS) / AtS' .
 eq (endc: E,     AtS) / (endc: E',     AtS') = (endc: E',     AtS) / AtS' .
 eq (exitc: E,    AtS) / (exitc: E',    AtS') = (exitc: E',    AtS) / AtS' .
 eq (post: E,     AtS) / (post: E',     AtS') = (post: E',     AtS) / AtS' .
 eq (skip: E,     AtS) / (skip: E',     AtS') = (skip: E',     AtS) / AtS' .
 eq (pre: E,      AtS) / (pre: E',      AtS') = (pre: E',      AtS) / AtS' .
 eq (inv: E,      AtS) / (inv: E',      AtS') = (inv: E',      AtS) / AtS' .
 eq AtS / (repeatc: E',  AtS') = (repeatc: E',  AtS) / AtS' [owise] .
 eq AtS / (startc: E',   AtS') = (startc: E',   AtS) / AtS' [owise] .
 eq AtS / (endc: E',     AtS') = (endc: E',     AtS) / AtS' [owise] .
 eq AtS / (exitc: E',    AtS') = (exitc: E',    AtS) / AtS' [owise] .
 eq AtS / (post: E',     AtS') = (post: E',     AtS) / AtS' [owise] .
 eq AtS / (skip: E',     AtS') = (skip: E',     AtS) / AtS' [owise] .
 eq AtS / (pre: E',      AtS') = (pre: E',      AtS) / AtS' [owise] .
 eq AtS / (inv: E',      AtS') = (inv: E',      AtS) / AtS' [owise] .
 eq AtS / none = AtS .

 *** Processes TODO: Try to remove
 sort Nodes .
 op `[_`]          : Configuration -> Nodes .

endm
