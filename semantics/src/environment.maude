fmod VARIABLE-DECLARATION is
  protecting QUALIFIED .
  protecting VALUE .
  sort Variable .

  op _:_  : Qualified Value -> Variable [ctor prec 40] .
endfm

fmod STATE-ENTRY is
  protecting QUALIFIED .
  protecting VALUE .
  protecting ARGUMENTS .
  sort StateEntry .

  op _(_):_  : Qualified Arguments Value -> StateEntry [ctor prec 40] .
endfm

*** Global variable
fmod GLOBAL is
  protecting STATE-ENTRY .
  protecting COMMANDINFO .
  sort Global .
  subsort StateEntry < Global .
  subsort CommandInfo < Global .
endfm

view Global from TRIV to GLOBAL is
  sort Elt to Global .
endv

fmod SINGLE-INPUT is
  protecting QUALIFIED .
  protecting PARAMETER .
  protecting VALUE .
  protecting COMMAND-HANDLE .
  protecting ACK .

  sort Input StateInput CommandInput UpdateInput .
  subsort StateInput CommandInput UpdateInput < Input .

  op commandAbort  : Identifier Arguments Value         -> CommandInput .
  op commandAck    : Identifier Arguments CommandHandle -> CommandInput .
  op commandResult : Identifier Arguments Value         -> CommandInput .
  op stateLookup   : Identifier Arguments Value         -> StateInput   .
  op updateAck     : Identifier           Ack           -> UpdateInput  .
endfm

view Input from TRIV to SINGLE-INPUT is
  sort Elt to Input .
endv

fmod INPUTS is
  protecting SET{Input}
    * ( sort NeSet{Input} to NeInputs,
        sort Set{Input} to Inputs,
        op empty to noInputs,
        op _`,_ to __,
        op insert to insertInputs,
        op delete to deleteInputs,
        op _in_ to _inInputs_,
        op |_| to |_|Inputs,
        op $card to $cardInputs,
        op union to unionInputs,
        op intersection to intersectionInputs,
        op $intersect to $intersectInputs,
        op _\_ to _\Inputs_,
        op $diff to $diffInputs,
        op _subset_ to _subsetInputs_,
        op _psubset_ to _psubsetInputs_ ) .
endfm

view Inputs from TRIV to INPUTS is
  sort Elt to Inputs .
endv

fmod INPUTS-SET is
  protecting SET{Inputs}
    * ( sort NeSet{Inputs} to NeInputsSet,
        sort Set{Inputs} to InputsSet ) .

  op _x_ : InputsSet InputsSet -> InputsSet .
  eq InS x (In, In', InS') = ((InS x In), (InS x (In',InS'))) .
  eq (In,InS) x In' = (In In', (InS x In')) .
  eq InS x empty = empty .
  eq empty x InS = empty .

  vars In In' : Inputs .
  vars InS InS' : InputsSet .

endfm

fmod INPUTS-LIST is
  protecting INPUTS .
  sort EInputsList NeEInputsList .
  subsort Inputs < NeEInputsList < EInputsList .
  op nilEInputsList : -> EInputsList .
  op _#_ : EInputsList   EInputsList   -> EInputsList   [assoc id: nilEInputsList prec 50] .
  op _#_ : NeEInputsList EInputsList   -> NeEInputsList [ditto] .
  op _#_ : EInputsList   NeEInputsList -> NeEInputsList [ditto] .
endfm

*** Set of global variables
fmod ENVIRONMENT is
  protecting SET{Global} * ( sort NeSet{Global} to NeEnvironment,
                             sort Set{Global} to Environment,
                             op empty to mtenvironment ) .

  vars E E' : Environment .
  vars Q Q' : Qualified .
  vars V V' : Value .
  vars H H' : CommandHandle .
  vars Args : Arguments .

  *** TODO: To erase if it is not used
  op _/_ : Environment Environment -> [Environment] [prec 80] .
  eq (Q(Args) : V, E) / (Q(Args) : V', E') = (Q(Args) : V', E) / E' .
  eq E / (Q(Args) : V', E') = (Q(Args) : V', E) / E' [owise] .
  eq E / mtenvironment = E .

endfm

*** List of Environments TODO: Possibly convert into List{X}
fmod ENVIRONMENTS is
  protecting ENVIRONMENT .
  sort EnvironmentList .
  sort Environments .
  subsort Environment < EnvironmentList .

  op nilenvironments : -> EnvironmentList .
  op _#_ : EnvironmentList EnvironmentList -> EnvironmentList [assoc id: nilenvironments] .
  op `{_`} : EnvironmentList -> Environments .
endfm
