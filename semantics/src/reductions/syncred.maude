----                                                     Synchronous reductions
----                                                       author: Camilo Rocha

fmod SYNC-REDUCTION is

protecting FUNPRED .

var A            : Action .
var AS           : ActionSet .
vars NA AtS AtS' : AttributeSet .
vars B B'        : Bool .
var CC           : Cid .
vars C C'        : Command .
vars CI CI'      : CommandInfo .
var Conf         : Config .
vars PS PS' PS'' : Configuration .
var Gamma        : Environment .
vars E E'        : Expression .
var  ES          : ExpressionSet .
vars I           : Identifier .
vars N           : Nat .
vars O O'        : Outcome .
vars Q Q'        : NeQualified .
vars S S' T T'   : Status .
var Str          : String .
var Tr           : Trace .
var TL           : TraceList .
var TS           : TransitionSet .
vars V V' V''    : Value .

op logApplyActions : Config -> Config .
eq logApplyActions([ nodes : < Q : CC | status: S, AtS > PS ]
                   [ microacts : setStatus(Q,S'),AS ]
                   Conf )
 = logApplyActions([ nodes : < Q : CC | status: S', AtS > PS ]
                   [ microacts : AS ]
                   Conf ) [print "    " Q " from " S " to " S'] .
eq logApplyActions(Conf) = mtsoup [owise] .

op applyActions : Config ~> Config .
eq applyActions ([ trace :         TL ] Conf)
 = applyActions'([ trace : mttrans TL ] Conf) .

op applyActions' : Config -> Config .
eq applyActions'([ nodes : < Q : CC | status: S, AtS > PS ]
                 [ microacts : setStatus(Q,S'),AS ]
                 Conf )
 = applyActions'([ nodes : < Q : CC | status: S', AtS > PS ]
                 [ microacts : AS ]
                 Conf ) .
eq applyActions'([ nodes : < Q : CC | outcome: O, AtS > PS ]
                 [ microacts : setOutcome(Q,O'),AS ]
                 Conf )
 = applyActions'([ nodes : < Q : CC | outcome: O', AtS > PS ]
                 [ microacts : AS ]
                 Conf ) .
eq applyActions'([ nodes : < Q : command | outcome: O, AtS > PS ]
                 [ interface : < I . Q : command-on-execution | AtS' > PS' ]
                 [ microacts : resetNode(Q),AS ]
                 Conf )
 = applyActions'([ nodes : < Q : command | outcome: none, AtS > PS ]
                 [ interface : PS' ]
                 [ microacts : AS ]
                 Conf ) .
eq applyActions'([ nodes : < Q : CC | outcome: O, AtS > PS ]
                 [ microacts : resetNode(Q),AS ]
                 Conf )
 = applyActions'([ nodes : < Q : CC | outcome: none, AtS > PS ]
                 [ microacts : AS ]
                 Conf ) [owise] .
eq applyActions'([ nodes : < Q : CC | suspended: B, AtS > PS ]
                 [ microacts : suspend(Q),AS ]
                 Conf )
 = applyActions'([ nodes : < Q : CC | suspended: true, AtS > PS ]
                 [ microacts : AS ]
                 Conf ) .
eq applyActions'([ nodes : < Q : CC | commandInfo: CI,  AtS > PS ]
                 [ microacts : setCommandInfo(Q,CI'),AS ]
                 Conf )
 = applyActions'([ nodes : < Q : CC | commandInfo: CI', AtS > PS ]
                 [ microacts : AS ]
                 Conf ) .
*** TODO: Logging of transitions should be handled in transparent way through `setStatus`
eq applyActions'([ microacts : logTransition(Q,S,T,N),AS ]
                 [ trace : TS TL ]
                 Conf )
 = applyActions'([ microacts : AS ]
                 [ trace : ((Q : S -[ pathLabel(N) ]-> T),TS) TL]
                 Conf ) .
eq applyActions'(Conf) = Conf [owise] .

  op pathLabel : Nat -> String .
  eq pathLabel(N) = "path-" + string(N,10) .



*** Activate redexes
op activateRedexes : Config -> Config .
eq activateRedexes([ nodes : < Q : CC | active: false, NA > PS ] Conf)
 = activateRedexes([ nodes : < Q : CC | active: true,  NA > PS ] Conf) .
eq activateRedexes(Conf) = Conf [owise] .

endfm
